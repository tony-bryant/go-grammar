# 概述
* 面向对象编程中方法 = 与特殊类型相关联的函数
* 通过方法操作对象
```
//使用方法
const day = 24 * time.Hour
fmt.Println(day.Seconds()) // "86400"

//定义方法String()
func (c Celsius) String() string { return fmt.Sprintf("%g°C", c) }
```
* 重点
  * 封装
  * 组合

# 方法声明
* 在函数声明前加上一个变量，即为该变量的方法
* 可以为任意类型命名方法
  * 除了指针
  * 除了interface  
* 给定类型方法名唯一
* 不同类型可以存在不同类型
  * 不需要通过类型来消除相同方法名的歧义
  * 可以减少包名+普通方法的调用  

# 基于指针对象的方法
* 避免复制大的实体
* 可以使用指针作为方法接收器
* 约定
  * 要么都不使用指针作为接收器
  * 要么都使用指针作为接收器
  * 不允许直接使用指针类型
    * type P *int
    * func (P) f() { /* ... */ }
* 无论接收器是指针还是非指针类型，都可以使用指针或者非指针进行调用 编译器会进行类型转换
* 非指针接收器会拷贝实体
* 指针接收器不会拷贝实体
* Nil也是一个合法的接收器类型

# 通过嵌入式结构体来扩展类型
* 使用小类型和小类型方法组合成大类型
* 组合>继承

# 方法值和方法表达式
* 选择一个方法，并在同一个表达式中执行
* p.Distance()
  * 将p绑定到特定接收器变量的函数
  * 调用时不需要指定接收器了
* 方法值
  * Point.Distance
* 方法表达式
 * 第一参数是实体类型 第二参数是函数参数
 * distance(p, q)
 * func (p Point) Distance(q Point) float64
* 将方法作为一种逻辑，同类型方法可以切换
# Bit数组
* go的set可以通过map[T]bool进行表示
* bit数组比map更理想
* bit数组
  * 无符号数
  * slice
* 每个字是64个二进制
* 不一定完全正确 参考布隆过滤器

# 封装
* 实体的变量和方法对外不可见 信息隐藏
* 大写字母会被导出到包外 小写字母不会
* 封装实体需要用到struct
* 优点
  * 调用方只需要关注可改变的变量
  * 异常实现的细节
  * **阻止外部调用方对对象内部的值进行修改**
    * 访问或修改变量的函数称为setter getter
    * getter函数可以省略Get前缀(包外访问 需要大写)
